\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{graphicx}
\usepackage{rotating}
\usepackage{caption}
\usepackage{amsmath}


\lstset {
    basicstyle=\footnotesize,      % font size
    numbers=left,                  % where to put line numbers
    numberstyle=\footnotesize,     % numbers size
    numbersep=5pt,                 % how far the line numbers are from the code
    backgroundcolor=\color{white}, % background color
    showspaces=false,                          % show spaces (with underscores)
    showstringspaces=false,            % underline spaces within strings
    showtabs=false,                            % show tabs using underscores
    frame=single,                  % adds a frame around the code
    tabsize=4,                     % default tabsize
    breaklines=true,                  % automatic line breaking
    columns=fullflexible,
    breakautoindent=false,
    framerule=1pt,
    xleftmargin=0pt,
    xrightmargin=0pt,
    breakindent=0pt,
    resetmargins=true
}

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
% Margins
\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\chead{\hspace{1cm}\hmwkClass} % Top center head
\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------
\newcommand{\hmwkTitle}{Project - Part2 : Report} % Assignment title
\newcommand{\hmwkClass}{INFO-F-403} % Course/class
\newcommand{\hmwkAuthorName}{Anthony Caccia, Rapha\"{e}l Vander Marcken} % Your name


\begin{document}
%----------------------------------------------------------------------------------------
% TITLE PAGE
%----------------------------------------------------------------------------------------
\begin{titlepage}
\begin{center}
\textbf{\textsc{UNIVERSIT\'E LIBRE DE BRUXELLES}}\\
\textbf{\textsc{Faculty of Sciences}}\\
\textbf{\textsc{Computer Science Department}}
\vfill{}
\begin{center}{\Huge \hmwkClass\\ \LARGE Introduction to language theory and compiling\\Project - Part 3 : Report}\end{center}{\Huge \par}
\begin{center}{\Large Anthony Caccia\\RaphaÃ«l Vander Marcken}\end{center}{\Huge \par}
\vfill{}
\vfill{}
\textbf{Academic Year 2016~-~2017}
\end{center}
\end{titlepage}

\section{Introduction}
For this part, we had to generate \emph{LLMV intermidiate representation} (LLVM IR) from the recursive descent parser we wrote in part 2.

\section{Generation}

First, entering the \emph{PROGRAM} part generate global variable and definitions, mainly for output to stdout and a function for input of signed integers. After this, the line declaring the main function is written. Here, we chose to not consider the program name and directly call it "main", since the language handle only on function per file. Another solution would have been to use the program name, and at the end of the program generating a main function that simply calls the program.

Then, we have to parse vars. For this task, the read variables are stocked inside a list and then, used to generate a variable inside the LLVM IR and is also stocked inside a set so every time we have to use a variable, we can check for its existence.

After that, we had to parse arithmetic expressions and conditions. They work on the same principle: they take terminals and associate them using unary and binary operators. Since we already had the recursion tree, this was fairly easy: when we see a terminal, we put it on a stack and if there is an operator after that, we push the operator\footnote{To make our life easier, we modified the lexer so when it crosses on operator, it directly binds the LLVM IR corresponding instruction to the generated symbol.} and the next arithmetic expression or condition, then we pop 3 elements from the stack and generate in LLVM IR a new variable which is the result of this operation on the two other popped elements. Then, we push this new variable on the stack, so it can be reused for recursivity. These operations of popping three elements, outputing LLVM IR and saving on stack are defined in three functions \textit{evaluateArith}, \textit{evaluateComp} and \textit{evaluateCond}, which are respectively for evaluating arithmetic expressions, comparisons and conditions.

The print and read operations are simple: they use save their arguments inside a list and then, output their corresponding LLVM IR function for all the arguments one by one.

For the "if-then-else", after the condition evaluation, we use a \textit{br i1} where the first label correspond to the case when it is true, it then write the corresponding LLVM IR code and then, write a \textit{br} to the label corresponding to the continuation of the code. Then, following the same principle, it writes the code corresponding to the else branch, even if this one does not exist. In this case, it will only contains one instuction: a \textit{br} to the continuation of the code.


\end{document}
